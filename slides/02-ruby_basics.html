<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Introducing Ruby</title>

		<meta name="description" content="Introducing Ruby">
		<meta name="author" content="ICT4g">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/serif.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h3>a bit of</h3>
					<h1>Ruby</h1>
					<br>
					<p>
						<small>by <a href="http://ict4g.org">ICT4g</a> / <a href="http://twitter.com/ict4g_fbk">@ict4g_fbk</a></small>
					</p>
					<code>#rorec14 #THIS_PLACE</code>
				</section>

				<section>
					<h1>the console</h1>
					<p>
						just type <code>irb</code> in your command shell
						<br>
						you should see something like
						<pre><code data-trim contenteditable style="font-size: 18px; margin-top: 20px;">
							irb(main):001:0>
						</code></pre>
						<code>irb</code> is the Interactive Ruby Shell
					</p>
					<div class="fragment">
						type <code>irb --prompt simple</code> for a shorter prompt
						<pre><code data-trim contenteditable style="font-size: 18px; margin-top: 20px;">
							>>
						</code></pre>
					</div>
				</section>
				<section>
					<h2>let's be traditional</h2>
					<p>when you learn a new language you always write the same Hello World program</p>
					<pre class="fragment roll-in"><code>
puts "Hello World!"
					</code></pre>
					<p class="fragment"><em>done</em></p>
				</section>
				<section>
					<h1>numbers</h1>
					<pre><code>
>> 4+3
=> 7
>> 4-5
=> -1
>> 42/6
=> 7
>> 6*7
=> 42
>> 2**10
=> 1024
					</code></pre>
					Ruby recognizes numbers and mathematic symbols.
				</section>

				<section>
					<section>
						<h1>strings</h1>
						to make a <em>string</em> just enclose the text in quotes
						<pre><code>
irb(main):002:0> "Grahamstown"
=> "Grahamstown"
						</code></pre>
					</section>
					<section>
						<h2>game of strings</h2>
						let's try to <code>reverse</code> it
						<div class="fragment roll-in">
							<pre><code data-trim>
irb(main):003:0> "Grahamstown".reverse
=> "nwotsmaharG"
						</code></pre></div>
						<p class="fragment">how long is Grahamstown?</p>
						<div class="fragment roll-in"><pre><code data-trim>
irb(main):004:0> "Grahamstown".length
=> 11
						</code></pre></div>
						<p class="fragment">let's repeat it</p>
						<div class="fragment roll-in"><pre><code data-trim>
irb(main):005:0> "Grahamstown" * 5
=> "GrahamstownGrahamstownGrahamstownGrahamstownGrahamstown"
						</code></pre></div>
						<p class="fragment">or SHOUT it out loud</p>
						<div class="fragment roll-in"><pre><code data-trim>
irb(main):006:0> "Grahamstown".upcase
=> "GRAHAMSTOWN"
						</code></pre></div>
					</section>
				</section>

				<section>
					<section>
						<h1>methods</h1>
						<code>reverse</code> and <code>*</code> are <em>methods</em>!<br>
						The correct term is <b>messages</b>
						<div class="fragment roll-in">
						<pre><code>
irb(main):001:0> 4.send(:+, 3)
=> 7
						</code></pre>
						<small>here we <code>send</code> the message <code>:+</code> with parameter <code>3</code> to the object <code>4</code></small>
						</div>
					</section>
					<section>
						<h2>wrong methods</h2>
						<pre><code>
irb(main):006:0> 42.reverse
NoMethodError: undefined method `reverse' for 42:Fixnum
						</code></pre>
						Ruby is telling us there is no method <code>reverse</code> for numbers.
						<p class="fragment">but we can do something like this</p>
						<div class="fragment roll-in">
							<pre><code>
irb(main):007:0> 42.to_s.reverse
=> "24"
							</code></pre>
						</div>
						<p class="fragment">or this</p>
						<div class="fragment roll-in">
							<pre><code>
irb(main):008:0> 42.to_s.reverse.to_i
=> 24
							</code></pre>
						</div>
					</section>
				</section>

				<section>
					<section>
						<h1>arrays</h1>
						What are arrays?! They are lists. <br>
						Type in a pair of brackets: <code>[]</code>
						<pre><code>
irb(main):010:0> [12, 78, 27]
=> [12, 78, 27]
						</code></pre>
						Lists store things <b>in order</b>.
					</section>
					<section>
						<h2>have fun with arrays</h2>
						<pre><code>
irb(main):011:0> [12, 78, 27].max
=> 78
irb(main):015:0> [12, 78, 27].last
=> 27
irb(main):016:0> [12, 78, 27].reverse
=> [27, 78, 12]
irb(main):017:0> [12, 78, 27].sort
=> [12, 27, 78]
						</code></pre>
					</section>
					<section>
						<h2>arrays and strings</h2>
						a <em>string</em> can be seen as an array of <code>chars</code>
						<pre><code>
>> "Grahamstown".chars.to_a
=> ["G", "r", "a", "h", "a", "m", "s", "t", "o", "w", "n"]
>> "Grahamstown".chars.to_a.reverse
=> ["n", "w", "o", "t", "s", "m", "a", "h", "a", "r", "G"]
>> "Grahamstown".chars.to_a.reverse.join
=> "nwotsmaharG"
>> "Grahamstown".reverse
=> "nwotsmaharG"
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>variables</h1>
						<em>Variables</em> save a thing and give it a name. <br>
						We use the equals sign to do this.
						<pre><code>
>> poker_cards = [20, 5, 1, 100, 8, 13, 0.5, 40, 2, 3, 0]
=> [20, 5, 1, 100, 8, 13, 0.5, 40, 2, 3, 0]
						</code></pre>
						<p class="fragment">We can call methods on variables (i.e. send them <em>messages</em>)</p>
						<div class="fragment roll-in">
							<pre><code>
>> poker_cards.sort!
=> [0, 0.5, 1, 2, 3, 5, 8, 13, 20, 40, 100]
							</code></pre>
						</div>
					</section>
					<section>
						<h2>what's that <code>!</code>?</h2>
						The exclamation at the end means that the method <code>sort!</code> changes what the variable contains for good.<br>
						So, after <code>poker_cards.sort!</code>:
						<pre><code>
>> poker_cards
=> [0, 0.5, 1, 2, 3, 5, 8, 13, 20, 40, 100]
						</code></pre>
						<strong>this is only a convention!</strong>
					</section>
					<section>
						<h2>there is also the <code>?</code></h2>
						<pre><code>
>> poker_cards.include? 42
=> false
>> poker_cards.include? 13
=> true
>> poker_cards.include? "âˆž"
=> false
>> poker_cards.empty?
=> false
						</code></pre>
						<strong>this is a convention too!</strong>
					</section>
				</section>

				<!-- Hash 1 -->
				<section>
					<section>
						<h1>hash</h1>
						a.k.a. dictionary, <code>HashTable</code>, <code>HashMap</code>, ...
						<p>a new hash of our favourite South African and Italian food</p>
						<pre><code>
>> food = {}
=> {}
						</code></pre>
						a hash is a set of <code>key => value</code> pairs, <em>unordered</em>
						<pre><code>
>> food["Italian Pizza"] = :very_good
=> :very_good
>> food
=> {"Italian Pizza"=>:very_good}
						</code></pre>
					</section>
					<section>
						<h2>what's that <code>:</code>?</h2>
						When you place a colon in front of a simple word, you get a <em>symbol</em>. Symbols are cheaper than strings (in terms of computer memory.) If you use a word over and over in your program, use a symbol. Rather than having thousands of copies of that word in memory, the computer will store the symbol only once.
					</section>
				</section>

				<!-- Hash 2 -->
				<section>
					<h2>let's add a few</h2>
					<pre><code>
>> food["South African Pizza"] = :not_so_good
=> :not_so_good
>> food["Boerewors"] = :very_good
=> :very_good
>> food["Bobotie"] = :dont_know
=> :dont_know
>> food["Biltong"] = :good
=> :good
>> food["Kudu"] = :excellent
=> :excellent
					</code></pre>
					and see how many
					<pre><code>
>> food
=> {"Italian Pizza"=>:very_good, "South African Pizza"=>:not_so_good, "Boerewors"=>:very_good, "Bobotie"=>:dont_know, "Biltong"=>:good, "Kudu"=>:excellent}
>> food.length
=> 6
					</code></pre>
				</section>

				<!-- Hash 3 -->
				<section>
					<section>
						<h2>fine dining in town?</h2>
						have a look to our ratings
						<p class="fragment">create a hash for storing the rates</p>
						<div class="fragment roll-in"><pre><code>
>> ratings = Hash.new(0)
=> {}
						</code></pre></div>
						<p class="fragment">and fill it with our ratings of food</p>
						<div class="fragment roll-in"><pre><code>
>> food.values.each { |rate| ratings[rate] += 1 }
=> [:very_good, :not_so_good, :very_good, :dont_know, :good, :excellent]
						</code></pre></div>
						<p class="fragment">here it is</p>
						<div class="fragment roll-in"><pre><code>
>> ratings
=> {:very_good=>2, :not_so_good=>1, :dont_know=>1, :good=>1, :excellent=>1}
						</code></pre></div>
					</section>
					<section>
						<h2>what's that <code>{|| ...}</code>?</h2>
						That piece of code is called a <em>block</em><br>
						that's how it works
						<pre><code>
>> food.values.each { |rate| ratings[rate] += 1 }
						</code></pre>
						<div style="text-align: left">
							<ul>
								<li><code>|rate|</code> is the <em>block variable</em></li>
								<li><code>ratings[rate] += 1</code> is the <em>block code</em></li>
							</ul>
							<p style="margin-top: .5em">
								each value of <code>food</code> is put into the <em>block variable</em>
								and the <em>block code</em> is executed.
							</p>
						</div>
					</section>
					<section>
						<h3>multi-line block</h3>
						when you have a huge block <br>
						you can write it using multiple lines
						<pre><code>
>> food.values.each do |rate|
?> 	ratings[rate] += 1
>> end
=> [:very_good, :not_so_good, :very_good, :dont_know, :good, :excellent]
>> ratings
=> {:very_good=>2, :not_so_good=>1, :dont_know=>1, :good=>1, :excellent=>1}
						</code></pre>
						<em>do</em> and <em>end</em> work for <em>{...}</em>
					</section>
				</section>

				<!-- Control flow -->
				<section>
					<section>
						<h1>control flow</h1>
						namely <code>if</code>, <code>else</code> stuff
						<pre><code data-trim>
>> s = "a string"
>> if s.empty?
>>   "The string is empty"
>> else
?>   "The string is nonempty"
>> end
=> "The string is nonempty"
						</code></pre>
						we can also use <code>unless</code>
						<pre><code data-trim>
>> x = "a variable"
>> puts "x is not empty" if !x.empty?
x is not empty
=> nil
>> puts "x is not empty" unless x.empty?
x is not empty
=> nil
						</code></pre>
					</section>
					<section>
						<h2>what's that <code>nil</code>?</h2>
						<code>nil</code> is a special <em>object</em>, similar to the Java <strong><code>null</code></strong><br>
						it is the only Ruby object that is <code>false</code> in a boolean context, apart from <code>false</code> itself
						<pre><code data-trim>
>> if nil
>> 	true
>> else
?> 	false
>> end
=> false
						</code></pre>
						all other Ruby objects are <code>true</code>, even 0
						<pre><code data-trim>
>> if 0
>> 	true
>> else
?> 	false
>> end
=> true
						</code></pre>
					</section>
				</section>
				<!-- the end -->

                <!-- each, map, inject -->
                <section>
                    <section>
                        <h1><code>each</code>, <code>map</code> and <code>inject</code></h1>
                        (your best friends when working on enumberables)
                    </section>
                    <section>
                        <h2><code>each</code></h2>
                        Execute the block on all the elements of <code>self</code>
                        <pre><code contenteditable>
>> (1..5).each do |element|
?> 	print element * 10, " "
>> end
10 20 30 40 50
                        </code></pre>
                    </section>
                    <section>
                        <h2><code>map</code></h2>
                        invokes the given block once for each element of <code>self</code> and creates a <em>new array</em> containing the values returned by the block
                        <pre><code contenteditable>
>> (1..5).map do |element|
?>   element * 2
>> end
=> [2, 4, 6, 8, 10]
                        </code></pre>
                    </section>
                    <section>
                        <h2><code>inject</code></h2>
                        combines all elements of <code>self</code> by applying a binary operation, specified by a block or a symbol that names a method or operator
                        <pre><code contenteditable>
>> ['cat','bear','ratazana','sheep'].inject do |memo,word|
?>   word.length > memo.length ? word : memo
>> end
=> "ratazana"
                        </code></pre>
                        <pre><code contenteditable>
>> [6, 4, 3, 3, 22].inject(1) { |accumulator,n| accumulator *= n }
=> 4752
                        </code></pre>
                    </section>
                </section>

				<!-- method def -->
				<section>
					<section>
						<h1>methods and classes</h1>
					</section>
					<section>
						<h2>method definitions</h2>
						<pre><code>
>> def palindrome?(string)
>> 	string == string.reverse
>> end
>> palindrome? "level"
=> true
						</code></pre>
						in Ruby functions have an implicit <em>return</em>,
						meaning they <em>return</em> the last statement evaluated <br>
						but dont'worry, the <code>return</code> statement exists too
					</section>
				</section>
				<section>
					<section>
						<h1>classes</h1>
						we define a new class like this
						<pre><code data-trim class="ruby">
>> class Word
>> 	def palindrome?(string)
>> 		string == string.reverse
>> 	end
>> end
=> nil
						</code></pre>
						and we use it
						<pre><code data-trim>
>> w = Word.new
=> #&lt;Word:0x007fb8759a97e8&gt;
>> w.palindrome? "level"
=> true
						</code></pre>
						Itâ€™s odd to create a new class just to create a method that takes a string as an argument
					</section>
				</section>
				<section>
					<section>
						<h2>extending classes</h2>
						we can define <code>Word</code> as a subclass of <code>String</code>
						<pre><code>
>> class Word &lt; String
>> 	def palindrome?
>> 		self == self.reverse
>> 	end
>> end
=> nil
						</code></pre>
						<code>self</code> is similar to <code>this</code> in Java
						<pre><code>
>> w = Word.new("level")
=> "level"
>> w.palindrome?
=> true
						</code></pre>
					</section>
					<section>
						<p>we obviously inherited all the methods of <code>String</code></p>
						<pre><code>
>> w.length
=> 5
						</code></pre>
						and we can see the inheritance of our new class
						<pre><code>
>> w.class.superclass
=> String
>> w.class.superclass.superclass
=> Object
>> w.class.superclass.superclass.superclass
=> BasicObject
						</code></pre>
					</section>
					<section>
						<h2>something cool of Ruby</h2>
						we don't need to extend <code>String</code> to add new methods to it
						<pre><code class="ruby">
>> class String
>>   def palindrome?
>>     self == self.reverse
>>     end
>>   end
=> nil
>> "level".class
=> String
>> "level".palindrome?
=> true
						</code></pre>
						this is called <em>opening a built-in class</em><br>
						<p>And you should do it only if you have a <strong>REALLY</strong> good reason</p>
					</section>
				</section>
				<section>
					<section>
						<h2>let's create a User!</h2>
						(you can use an editor and then call<br><code>require '&lt;/path/to/your/file&gt;.rb'</code>)
						<pre><code>
class User
  attr_accessor :name, :email

  def initialize(attributes = {})
    @name  = attributes[:name]
    @email = attributes[:email]
  end

  def formatted_email
    "#{@name} &lt;#{@email}&gt;"
  end
end
						</code></pre>
						Yeah... that's a lot of new stuff...
					</section>
					<section>
						<h2>initializers</h2>
						<pre><code>
def initialize(attributes = {})
  @name  = attributes[:name]
  @email = attributes[:email]
end
						</code></pre>
						<p>is called everytime we call <code>User.new</code></p><br>
						<p>More or less like Java constructors</p>
					</section>
					<section>
						<h2>Getters and setters</h2>
						<pre><code>
attr_accessor :name, :email
						</code></pre>
						<p>automatically creates getters and setters for the attributes <code>:name</code> and <code>:email</code></p><br>
						<p>so that we can call them like this:</p>
						<pre><code>
@name  = attributes[:name]
@email = attributes[:email]
						</code></pre>
					</section>
					<section>
						<h2>what's that <code>@</code>?</h2>
						<p><code>@name</code> means that <code>name</code> is an <em>instance variable</em></p>
						<pre><code>
>> u
=> #&lt;User:0x00000000f42a68 @name="Aaron", @email="aaron@example.com"&gt;
						</code></pre>
						<p class="fragment">each instance variable is dynamically appended to an object when it is first assigned</p>
						<div style="width: 50%; float: left"><pre class="fragment roll-in"><code style="overflow:hidden">
def address=new_address
  @address = new_address
end
						</code></pre></div>
						<div style="width: 50%; float: left"><pre class="fragment roll-in"><code style="overflow:hidden">
def address
  @address
end
						</code></pre></div>
					</section>
                    <section>
                        <h2>and what's that <code>#{...}</code>?</h2>
                        <p><code>#{}</code> is called <em>interpolation</em> and it allows you to embed (the string representation of) a variable in a string</p>
                        <pre><code>
>> a = 15;
?> "I have #{a} cats"
=> "I have 15 cats"
>> array = [15,7,4,'braai'];
?>   "this is an array: #{array}"
=> "this is an array: [15, 7, 4, \"braai\"]"
>> "The time now is #{Time.now}"
=> ...
                        </code></pre>
                    </section>
					<section>
						<h2>let's see it in action</h2>
						<pre><code>
>> u = User.new(name: 'Aaron', email: 'aaron@example.com')
=> #&lt;User:0x00000000f42a68 @name="Aaron", @email="aaron@example.com"&gt;
>> u.formatted_email
=> "Aaron &lt;aaron@example.com&gt;"
						</code></pre>
					</section>
                    <section>
                        <h2>one more thing: class methods vs instance methods</h2>
                        <div class="fragment roll-in" style="width: 50%; float: left">
                            instance method
                            <pre><code style="overflow:hidden">
def activate!
  @active = true
end
#=======
>> u.activate!
=> true
                            </code></pre>
                        </div>
                        <div class="fragment roll-in" style="width: 50%; float: left">
                            class method
                            <pre><code style="overflow:hidden">
def self.default_user
  User.new(
    name: 'Homer',
    email: 'homer@example.com'
  )
end
#=======
>> User.default_user
=> #&lt;User:0x00000000f5b888 @name="Estenio", @email="estenio@example.com"&gt;
                            </code></pre>
                        </div>
                    </section>
				</section>
				<section>
            <h1>Documentation</h1>
            <p>All you need to know</p><br>
            <p><a href="http://ruby-doc.org/core-2.1.0/">http://ruby-doc.org/core-2.1.0/</a></p>
        </section>
				<section>
					<h1>THE END</h1>
					<p>this presentation is widely inspired by <a href="http://tryruby.org">tryruby.org</a></p>
					<p>check it out to repeat the lesson!</p>
                    <p>you can also try <a href="http://iwanttolearnruby.com/">http://iwanttolearnruby.com/</a></p>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
